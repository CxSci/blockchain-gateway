## DLT Gateway Crash Recovery Specification
### draft-belchior-blockchain-gateway-recovery-03

#### R. Belchior (INESC-ID, Instituto Superior Tecnico)
#### M. Correia (INESC-ID, Instituto Superior Tecnico)
#### T. Hardjono (MIT)

### Abstract
This memo describes the crash recovery mechanism for the Open Digital Asset Protocol (ODAP), called ODAP-2PC.
The goal is to assure gateways running ODAP to be able to recover from crashes, and thus preserve the consistency of an asset across ledgers 
(i.e., double spend does not occur).

This draft includes the description of the messaging and logging flow necessary for the correct functioning of  ODAP-2PC.

### 1. Introduction

Gateway systems that perform virtual asset transfers among DLTs must possess a degree of resiliency and fault tolerance in the face of possible crashes. Accounting for the possibiility of crashes is 
particularly important to guarantee asset consistency across DLTs.

ODAP-2PC [HERMES] uses 2PC, an atomic commitment protocol (ACP).
2PC considers two roles: a Coordinator that manages the execution of the protocol and Participants that manage the resources that must be kept consistent. The source gateway plays the ACP role of Coordinator, and the recipient gateway plays the Participant role in relay mode. Gateways exchange messages corresponding to the protocol execution, generating log entries for each one.

Log entries are organized into logs. Logs enable either the same or other backup gateways to resume any phase of ODAP. This log can also serve as an accountability tool in case of disputes.
Another key component is an atomic commit protocol (ACP) that guarantees that the source and target DLTs are modified consistently (atomicity) and permanently (durability), e.g., that assets that are taken from the source DLT are persisted into the recipient DLT.   

Log entries are then the basis satisfying one of the key deployment requirements of gateways for asset transfers:
a high degree of availability. In this document, we consider two common strategies to increase availability: (1) to support the recovery of the gateways and (2) to employ backup gateways with the ability to resume a stalled transfer.


This memo proposes: 
(i) the logging model of ODAP-2PC; 
(ii) the log storage types;
(iii) the log storage API;
(iv)  the log entry format;
(v) the recovery and rollaback procedures;


### 2. Terminology

* Gateway: The nodes of a DLT system that are functionally capable of handling an asset transfer with another DLT. Gateway nodes implement the gateway-to-gateway asset transfer protocol.


* Primary Gateway: The node of a DLT system that has been selected or elected to act as a gateway in an asset transfer.


* Backup Gateway: The node of a DLT system that has been selected or elected to act as a backup gateway to a primary gateway.


* Message Flow Parameters: The parameters and payload employed in a message flow between a sending gateway and receiving gateway.


* Source Gateway: The gateway that initiates the transfer protocol. Acts as a coordinator of the ACP and mediates the message flow.


* Recipient Gateway: The gateway that is the target of an asset transfer. It follows instructions from the source gateway.


* Source DLT: The DLT of the source gateway.


* Target DLT: The DLT of the recipient gateway.


* Log: Set of log entries such that those are ordered by the time of its creation.


* Public (or Shared) Log: log where several gateways can read and write from it.


* Private Log: log where only one gateway can read and write from it.


* Log data: The log information is retained by a gateway connected to an exchanged message within an asset transfer protocol.


* Log entry: The log information generated and persisted by a gateway regarding one specific message flow step.


* Log format: The format of log-data generated by a gateway.


* Atomic commit protocol (ACP): A protocol that guarantees that assets that are taken from a DLT are persisted into the other DLT. Examples are two and three-phase commit protocols (2PC, 3PC, respectively) and non-blocking atomic commit protocols.


* Fault: A fault is an event that alters the expected behavior of a system.


* Crash-fault tolerant models: models allowing a system to keep operating correctly despite having a set of faulty components.


* Digital asset: a form of digital medium recordation that is used as a digital representation of a tangible or intangible asset.

### 3. Logging Model
Gateways store logs to map state. Besides private logs that gateways can use to log business-related information, there is a state log, that can be public, private, or semi-private. The type of the state log depends on the trust assumptions among gateways and on the access mode [ODAP].

By default, if there are gateways from different institutions involved in an asset transfer, the storage mode should be a decentralized log storage. The decentralized log storage can provide a common source of truth to solve disputes and maintain shared state, alleviating trust assumptions between gateways.

We consider the log file to be a stack of log entries. Each time a log entry is added, it goes to the top of the stack (the highest index).

To manipulate the log, we define a set of log primitives, that translate log entry requests from a process into log entries, realized by the log storage API (for the context of ODAP, Section 3.5):

1. writeLogEntry(e,L) (WRITE) - appends a log entry e in the log L (held by the corresponding Log Storage Support).

2. getLogEntry(i,L) (READ) - retrieves a log entry with index i from log L.

From these primitives, other functions can be built:

3. getLogLength (L) (READ) - obtains the number of log entries from log L.

4. getLogDiff(l1,l2) (READ) - obtains the difference between two logs. 

5. getLastEntry(L): obtains the last log entry from log L.

6. getLog(L): retrieves the whole log L.

7. updateLog(l1,l2): updates l1 based on l2 (uses getLogDiff and writeLogEntry).

Example 3.1 shows a simplified version log referring to the transfer initiation flow ODAP phase. Each log entry
(simplified, definition in Section 3) is composed by metadata (phase, sequence number) and one attribute from the payload (operation).
Operations map behavior to state (see Section 3).

The following table illustrates the log storage API. The Function describes the primitive supported by the log storage API. 
The Parameters column specifies the parameters given to the endpoint as query parameters. Endpoint specifies the endpoint mapping a certain log primitive.
The column Returns specifies what the contents of "response_data" mean. This last field is illustrated by column Response Example.


#### 3.1 Example
     ┌──┐                     ┌──┐                                 ┌───────┐
     │G1│                     │G2│                                 │Log API│
     └──┘                     └──┘                                 └───────┘
      │             [1]: writeLogEntry <1,1,init-validate>             │    
      │ ───────────────────────────────────────────────────────────────>    
      │                        │                                       │    
      │ initiate ODAP's phase 1│                                       │    
      │ ───────────────────────>                                       │    
      │                        │                                       │    
      │                        │ [2]: writeLogEntry <1,2,exec-validate>│    
      │                        │ ──────────────────────────────────────>    
      │                        │                                       │    
      │                        │────┐                                  │    
      │                        │    │ execute validate from p1         │    
      │                        │<───┘                                  │    
      │                        │                                       │    
      │                        │ [3]: writeLogEntry <1,3,done-validate>│    
      │                        │ ──────────────────────────────────────>    
      │                        │                                       │    
      │                        │ [4]: writeLogEntry <1,4,ack-validate> │    
      │                        │ ──────────────────────────────────────>    
      │                        │                                       │    
      │   validation complete  │                                       │    
      │ <───────────────────────                                       │    
     ┌──┐                     ┌──┐                                 ┌───────┐
     │G1│                     │G2│                                 │Log API│
     └──┘                     └──┘                                 └───────┘

Example 2.1 shows the sequence of logging operations over part of the first phase of ODAP (simplified):

1. At step 1, G1 writes an init-validate operation, meaning it will require G2 to initiate the validate function:
  This generates a log entry (p1, 1, init-validate).

2. At step 2, G2 writes an exec-validate operation, meaning it will try to execute the validate function:
  This generates a log entry (p1, 2, exec-validate).

3. At step 3, G2 writes an done-validate operation, meaning it successfully executed the validate function:
  This generates a log entry (p1, 3, done-validate).

4. At step 4, G2 writes an ack-validate operation, meaning it will send an acknowledgement to G1 regarding the done-validate:
  This generates a log entry (p1, 4, ack-validate).




#### 3.2 Log Storage Modes

Different log storage modes (or log support) exist: public, semi-private, and private.

1. The public log is stored on a decentralized log storage (e.g., blockchain-based). Each gateway writes log entries to a decentralized log storage, in plain text.
Although this is the best option for providing availability and integrity of the logs, leading to shorter dispute resolution, this can cause privacy issues.
This mode is recommended when gateways operate in the  Relay Mode: Client-initiated Gateway to Gateway. This mode can also be used by the Direct Mode: Client to Multiple Gateway access mode because gateways may need to share state between themselves.
Note: the difference between the mentioned modes is that in Direct Mode: Client to Multiple Gateway, a single client/organization controls all the gateways, whereas in the Relay Mode, gateways are controlled by different organizations.

2. Gateways can opt for a semi-private log. Each gateway saves the state log locally. For each state log entry a gateway stores locally (or in a cloud service), a hash of that log is published in a decentralized log storage.
This still ensures integrity, but lower availability guarantees, since a gateway needs to wait for the counter-party gateway to deliver the logs. The integrity of the log can be asserted by hashing the entries and comparing it to each stored hash on the decentralized log storage.
In this case, the decentralized log storage acts as a notarizing service. This mode is recommended for the Direct Mode: Simple Client to Gateway because gateways can prove past behavior to auditors. 

3. The private log storage mode, each gateway stores logs locally. If needed, logs are asked from the counter-party gateway.
Saving logs locally is faster than saving them on the respective ledger but delivers weaker integrity and availability guarantees.
Saving log entries on a DLT may slow down the protocol because issuing a transaction is several orders of magnitude slower than writing on disk or accessing a cloud service. In addition to the above modes, gateways can support the private log storage mode.

Each log storage mode provides a different process to recover state from crashes. In the private log, a gateway simply asks for the most recent log from the counter-party gateway. This is the mode where the most trust is needed.
In the semi-private mode, the gateway performs the steps from the private mode, and additionally checks the integrity of logs against the logs storage on the decentralized log storage.
In the public mode, the crashed gateway retrieves the most recent log from the decentralized log storage. This is the most trustless and decentralized mode of operation.





We assume the storage service used provides the means necessary to assure the logs' confidentiality and integrity, stored and in transit. The service must provide an authentication and authorization scheme, e.g., based on OAuth and OIDC [OIDC], and use secure channels based on TLS/HTTPS [TLS].

#### 3.3 Log Storage API

The log storage API allows for developers to abstract the log storage support, providing a standardized way
to interact with logs (e.g., relational vs. non-relational, local vs on-chain). It also handles access control if needed.

| Function                                                      | Parameters                       | Endpoint                                                               |
|---------------------------------------------------------------|----------------------------------|------------------------------------------------------------------------|
| Append log entry                                              | logId - log entry to be appended | POST / writeLogEntry/:logId Host: example.org Accept: application/json |
| Obtains a log entry                                           | id - log entry id                | GET getLogEntry/:id Host: example.org                                  |
| Obtains the length of the log                                 | None                             | GET getLogLength Host: example.org                                     |
| Obtains the difference  between a given log and a current log | log - log to be compared         | GET getLogDiff Host: example.org                                       |
| Obtains the last log entry                                    | None                             | GET getLastEntry Host: example.org                                     |
| Obtains the whole log                                         | None                             | GET getLog Host: example.org                                           |

The following table maps the respecetive return values and response examples:

| Returns                                  | Response Example                                                                                                                                      |
|------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| The entry index of the last log (string) | HTTP/1.1 200 OK Cache-Control: private Date: Mon, 02 Mar 2020 05:07:35 GMT Content-Type: application/json { "success": true, "response_data":"2" }    |
| A log entry                              | HTTP/1.1 200 OK Cache-Control: private Date: Mon, 02 Mar 2020 05:07:35 GMT Content-Type: application/json { "success": true, "response_data": {...} } |
| The length of the log (string)           | HTTP/1.1 200 OK Cache-Control: private Date: Mon, 02 Mar 2020 05:07:35 GMT Content-Type: application/json { "success": true, "response_data":"2" }    |
| The difference between two logs          | HTTP/1.1 200 OK Cache-Control: private Date: Mon, 02 Mar 2020 05:07:35 GMT Content-Type: application/json { "success": true, "response_data": {...} } |
| A log entry                              | HTTP/1.1 200 OK Cache-Control: private Date: Mon, 02 Mar 2020 05:07:35 GMT Content-Type: application/json { "success": true, "response_data": {...} } |
| The log                                  | HTTP/1.1 200 OK Cache-Control: private Date: Mon, 02 Mar 2020 05:07:35 GMT Content-Type: application/json { "success": true, "response_data": {...} } |
#### 3.3.1.  Response Codes
The log storage API  MUST respond with return codes indicating the failure (error 5XX)
or success of the operation (200).  The application may carry out further operation in future
to determine the ultimate status of the operation.

The log storage API response is in JSON format and contains two fields: 1) success: true if the operation was successful, 
and 2) response_data: contains the payload of the response generated by the log storage API.

## 4. Format of log entries

The log entries are stored by a gateway in its log, and they capture gateways operations. Entries account for the current status of one of the three ODAP flows: Transfer Initiation flow, Lock-Evidence flow, and Commitment Establishment flow.

The recommended format for log entries is JSON [xxx], with protocol-specific mandatory fields,  support for a free format field for plaintext or encrypted payloads directed at the DLT gateway or an underlying DLT. Although the recommended format is JSON, other formats can be used (e.g., XML).




The mandatory fields of a log entry, that are generated by ODAP, are:

- Version: ODAP protocol Version (major, minor).

- Session ID: unique identifier (UUIDv2) representing a session.

- Sequence Number: monotonically increasing counter that uniquely represents a message from a session.

- ODAP Phase: current ODAP phase.

- Resource URL: Location of Resource to be accessed.

- Developer URN: Assertion of developer / application identity.

- Action/Response: GET/POST and arguments (or Response Code).

- Credential Profile: Specify type of auth (e.g.	SAML, OAuth, X.509).

- Credential Block: Credential token, certificate, string.

- Payload Profile: Asset Profile provenance and capabilities.

- Application Profile: Vendor or Application specific profile

- Payload: Payload for POST, responses, and native DLT txns. The payload is specific to the current ODAP phase.

- Payload Hash: hash of the current message payload.


In addition to the attributes that belong to ODAP s schema, each log entry REQUIRES the following attributes:

* timestamp REQUIRED: timestamp referring to when the log entry was generated (UNIX format).

* source_gateway_pubkey REQUIRED: the public key of the gateway initiating a transfer.

* source_gateway_dlt_system REQUIRED: the ID  of the source DLT.

* recipient_gateway_pubkey REQUIRED: the public key of the gateway involved in a transfer.

* recipient_gateway_dlt_system REQUIRED: the ID of the recipient gatewayinvolved in a transfer.

* logging_profile REQUIRED: contains the profile regarding the logging procedure. Default is local store.

* Message_signature REQUIRED: Gateway EDCSA signature over the log entry.

* Last_entry_hash REQUIRED: Hash of previous log entry.

* Access_control_profile REQUIRED: the profile regarding the confidentiality of the log entries being stored. Default is only the gateway that created the logs can access them.

* Operation: the high level operation being executed by the gateway on that step.
  There are five types of operations:

1. Operation init- states the intention of a node to execute a particular operation.

2. Operation exec- expresses that the node is executing the operation.

3. Operation done- states when a node successfully executed a step of the protocol.

4. Operation ack- refers to when a node acknowledges a message received from another (e.g., command executed).

5. Operation fail- occurs when an agent fails to execute a specific step.

* operation history: a map between operations and sequence numbers of odap


Optional log entry fields are:

* source_gateway_uid OPTIONAL: the uid of the source gateway involved in a transfer.

* recipient_gateway_uid : the uid of the recipient gateway involved in a transfer.

* recovery message: the type of recovery message, if gateway is involved in a recovery procedure.

* recovery payload: the payload associated with the recovery message.

Example of a log entry created by G1, corresponding to locking an asset (phase 2.3 of the ODAP protocol) :

``{
"sessionId": "4eb424c8-aead-4e9e-a321-a160ac3909ac",
"seqNumber": 6,
"phaseId": "lock",
"sourceGatewayId": "5.47.165.186",
"sourceDltId": "Hyperledger-Fabric-JusticeChain",
"targetGatewayId": "192.47.113.116",
"targetDltId": "Ethereum",
"timestamp": "1606157330",
"payload": {
"messageType": "2pc-log",
"message": "LOCK_ASSET",
"votes": "none"
},
"payloadHash": "80BCF1C7421E98B097264D1C6F1A514576D6C9F4EF04955FA3AEF1C0664B34E3",
"logEntryHash": "[...]"
}``



Example of a log entry created by G2, acknowledging G1 locking an asset (phase 2.4 of the ODAP protocol) :

``{
"sessionId": "4eb424c8-aead-4e9e-a321-a160ac3909ac",
"seqNumber": 7,
"phaseId": "lock",
"sourceGatewayId": "5.47.165.186",
"sourceDltId": "Hyperledger-Fabric-JusticeChain",
"targetGatewayId": "192.47.113.116",
"targetDltId": "Ethereum",
"timestamp": "1606157333",
"payload": {
"messageType": "2pc-log",
"message": "LOCK_ASSET_ACK",
"votes": "none"
}
,
"payloadHash": "84DA7C54F12CE74680778C22DAE37AEBD60461F76D381D3CD855B0713BB98D1",
"logEntryHash": "[...]"
}``


## 6. ODAP-2PC
This section defines general considerations about crash recovery.
ODAP-2PC is the application of the gateway crash recovery mechanism to asset transfers, across all ODAP phases.

### 6.1 Crash Recovery Model

We assume gateways fail by crashing, i.e., by becoming silent, not arbitrary or Byzantine faults. We assume authenticated reliable channels obtained using TLS/HTTPS [TLS]. To recover from these crashes, gateways store in persistent storage data about the step of their protocol. This allows the system to recover by getting from the log the first step that may have failed. We consider two recovery models:

* Self-healing mode: assumes that after a crash, a gateway eventually recovers;
 The recovered gateway informs the other party of its recovery and continues the protocol execution;

* Primary-backup mode: assumes that after a crash, a gateway may never recover, but that this failure can be detected by timeout [AD76].
When a node is crashed indefinitely, a backup is spun off, using the log storage API to retrieve the most recent version of the log.

In Self-healing mode, when a gateway restarts after a crash, it reads the state from the log and continues executing the protocol from that point on.  We assume the gateway does not lose its long-term keys (public-private key pair) and can reestablish all TLS connections.



In Primary-backup mode, we assume that after a period T of the primary gateway failure, a backup gateway detects that failure unequivocally and takes the role of the primary gateway. The failure is detected using heartbeat messages and a conservative value for T. The backup gateway does virtually the same as the gateway in self-healing mode: reads the log and continues the process. The difference is that the log must be shared between the primary and the backup gateways. If there is more than one backup, a leader-election protocol may be executed to decide which backup will take the primary role.


### 6.2 Recovery Procedure

Gateways can crash at several points of the protocol.

In 2PC and 3PC, recovery requires that the protocol steps are recorded in a log immediately before sending a message and immediately after receiving a message. When a node crashes:



Upon recovery, the recovered node attempts to retrieve the most recent log of operations. 
Two situations might occur: 
for gateways with their local log plus a shared log, the crashed gateway attempts to perform an update to its local log, using getLogDiff from the shared log.


If there is no shared log, the crashed gateway needs to synchronize itself with the counter-party gateway, by querying the counter-party gateway with a recovery message containing the latest log before crash.
This message allows the non-crashed log to collect the potentially missing log entries from the crashed log. After that, the non-crashed log shares those entries with the now recover gateway.

The recovered gateway can now reconstruct the updated log and derive the current state of the asset transfer.
For each phase:

#### 6.2.1 Transfer  Initiation  Flow
For every step of this phase, logs are written before operations are executed. A log entry is written when an operation finishes its execution.
If a gateway crashes, upon recovery, it sends a special message RECOVER to the counter-party gateway. The counter-party gateway derives the latest log entry the recover gateway holds, and calculates the difference between its own log (RESPONSE-UPDATE).
After that, it sends it back to the recovered gateway, which then updates its own log. After that, a recovery confirmation message is sent (RECOVERY-CONFIRM), and the respective acknowledgment sent by the counter-party gateway (RECOVERY-ACK).
The gateways now share the same log, and can proceed its operation.
Note that if the shared log is blockchain or cloud based, the same flow applies, but the recovered gateway derives the new log, rather than the counter-party gateway.

#### 6.2.2 Lock-Evidence  Flow
If a crash occurs during the lock-evidence flow, the procedure is the same as the transfer initiation flow. However

#### 6.2.3 Commitment Establishment  Flow
This flow requires changes in distributed ledgers - which implies issuing transactions against them.
As transactions cannot be undone on blockchains, we use a rollback list - keeping an history of the issued transactions.
If a crash occurs and requires reverting state, transactions with the contrary effects of what is present on the rollaback lists are issued.

1. Rollback lists for all the gateways involved are initialized.

2. On step 2.3, add a pre-lock transaction to the source gateway rollback list.

3. On step 3.2, if the request is denied, then abort the transaction and apply rollbacks on the source gateway.

4. On step 3.3, add a lock transaction to the source gateway rollback list.

5. On step 3.4, if the commit fails, then abort the transaction and apply rollbacks on the source gateway.

6. On step 3.5,  add a create asset transaction to the rollback list of the recipient gateway.

7. On step 3.8, if the commit is successful, ODAP terminates.

8: Otherwise, if the last commit is not successful, then abort the transaction and apply rollbacks to both gateways.


### 6.3 ODAP-2PC Messages
ODAP-2PC messages are used to recover from crashes at the several ODAP phases.
These messages inform gateways of the current state of a recovery procedure.
ODAP-2PC messages follow log format from Section 4.

#### 6.3.1 RECOVER
A recover message is sent from the crashed gateway to the counter-party gateway, sending its most recent state.
This message type is encoded on the recovery message field of an ODAP log.

The parameters of the recovery message payload consists of the following:

* ODAP phase: latest ODAP phase registered.

* Sequence number: latest sequence number registered.

* Last_entry_hash REQUIRED: Hash of previous log entry.


#### 6.3.2 RECOVER-UDPDATE
The recover update message is sent by the counter-party gateway after receiving a recover message from a recovered gateway.
The recovered gateway informs of its current state (via the current state of the log).
The counter-party gateway now calculates the difference between the log entry corresponding to the received sequence number from the recovered gateway and
the latest sequence number (corresponding to the latest log entry).
This state is sent to the recovered gateway.

The parameters of the recover update payload consists of the following:

* recovered logs: the list of log messages that the recovered gateway needs to update

#### 6.3.3 RECOVER-UPDATE ACK 
The recover-update ack message (response to RECOVER-UPDATE) states if the recovered gateway's logs has been successfully updated.
If inconsistencies are detected, the recovered gateway answers with  initiates a dispute (RECOVER-DISPUTE message).

The parameters of this message consists of the following:

* success: true/false.

* entries changed: list of hashes of log entries that were appeded to the recovered gateway log.


#### 6.3.4 RECOVER-SUCCESS
The recover-ack message is sent by the counter-party gateway to the recovered gateway acknowledging that the state is synchronized.

The parameters of this message consists of the following:

* success: true/false


#### 6.3.5. ROLLBACK
A rollback message is sent by a gateway that initiated a rollback as defined by ODAP-2PC.

The parameters of this message consists of the following:

* success: true/false.

* actions performed: actions performed to rollback a state (e.g., UNLOCK; BURN).

* proofs: a lock-evidence proof specific to the DLT [ODAP]



#### 6.3.6 ROLLBACK-ACK
The rollback-ack message is sent by the counter-party gateway to the recovered gateway acknowledging that the rollback has been performed successfully.

The parameters of this message consists of the following:

* success: true/false


### 6.4 Examples 

There are several situations when a crash may occur.
#### 6.4.1 Crashing before issuing a command to the counter-party gateway

The following figure represents the source gateway (G1) crashing before it issued an init command to the recipient gateway (G2). 

     ┌──┐                           ┌──┐             ┌───────┐
     │G1│                           │G2│             │Log API│
     └──┘                           └──┘             └───────┘
      │     [1]: writeLogEntry <1, 1, init-validate>   │    
      │ ─────────────────────────────────────────────────>    
      │                              │                   │    
      │────┐                         │                   │    
      │    │ [2]  Crash              │                   │    
      │<───┘  ...                    │                   │    
      │      [3]recover              │                   │    
      │                              │                   │    
      │                              │                   │    
      │      [4] <1, 2, RECOVER>     │                   │    
      │ ─────────────────────────────>                   │    
      │                              │                   │    
      │                              │ [5] getLogEntry(i)│    
      │                              │ ──────────────────>    
      │                              │                   │    
      │                              │   [6] logEntries  │    
      │                              │ <─ ─ ─ ─ ─ ─ ─ ─ ─     
      │                              │                   │    
      │   [7] <1,3,RECOVER-UPDATE>   │                   │    
      │ <─────────────────────────────                   │    
      │                              │                   │    
      │────┐                         │                   │    
      │    │ [8] process log         │                   │    
      │<───┘                         │                   │    
      │                              │                   │    
      │              [9] <1,4,writeLogEntry>             │    
      │ ─────────────────────────────────────────────────>    
      │                              │                   │    
      │ [10] <1,5,RECOVER-UPDATE-ACK>│                   │    
      │ ─────────────────────────────>                   │    
      │                              │                   │    
      │   [11] <1,6,RECOVER-SUCESS>  │                   │    
      │ <─────────────────────────────                   │    
      │                              │                   │    
      │           [12]: <1,7,init-validateNext>          │    
      │ ─────────────────────────────────────────────────>    
     ┌──┐                           ┌──┐             ┌───────┐
     │G1│                           │G2│             │Log API│
     └──┘                           └──┘             └───────┘


#### 6.4.2 Crashing after issuing a command to the counter-party gateway

The second scenario requires further synchronization (figure below). At the retrieval of the latest log entry, G1 notices its log is outdated. It updates it upon necessary validation and then communicates its recovery to G2. The process then continues as defined.

     ┌──┐                           ┌──┐                             ┌───────┐
     │G1│                           │G2│                             │Log API│
     └──┘                           └──┘                             └───────┘
      │              [1]: writeLogEntry <1,1,init-validate>              │    
      │ ─────────────────────────────────────────────────────────────────>    
      │                              │                                   │    
      │   [2]: <1,1,init-validate>   │                                   │    
      │ ─────────────────────────────>                                   │    
      │                              │                                   │    
      │────┐                         │                                   │    
      │    │ [3] Crash               │                                   │    
      │<───┘                         │                                   │    
      │                              │                                   │    
      │                              │ [4]: writeLogEntry <exec-validate>│    
      │                              │ ──────────────────────────────────>    
      │                              │                                   │    
      │                              │────┐                              │    
      │                              │    │ [5]: execute init            │    
      │                              │<───┘                              │    
      │                              │                                   │    
      │                              │   [6]: writeLogEntry <done-init>  │    
      │                              │ ──────────────────────────────────>    
      │                              │                                   │    
      │                              │   [7]: writeLogEntry <ack-init>   │    
      │                              │ ──────────────────────────────────>    
      │                              │                                   │    
      │ [8] <1,2,init-validate-ack>  │                                   │    
      │  discovers that G1 crashed   │                                   │    
      │  via timeout                 │                                   │    
      │ <─────────────────────────────                                   │    
      │                              │                                   │    
      │────┐                         │                                   │    
      │    │ [9] Recover             │                                   │    
      │<───┘                         │                                   │    
      │                              │                                   │    
      │     [10] <1, 2, RECOVER>     │                                   │    
      │ ─────────────────────────────>                                   │    
      │                              │                                   │    
      │                              │        [11] getLogEntry(i)        │    
      │                              │ ──────────────────────────────────>    
      │                              │                                   │    
      │                              │          [12] logEntries          │    
      │                              │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─     
      │                              │                                   │    
      │   [13] <1,3,RECOVER-UPDATE>  │                                   │    
      │ <─────────────────────────────                                   │    
      │                              │                                   │    
      │────┐                         │                                   │    
      │    │ [14] process log        │                                   │    
      │<───┘                         │                                   │    
      │                              │                                   │    
      │                     [15] <1,4,writeLogEntry>                     │    
      │ ─────────────────────────────────────────────────────────────────>    
      │                              │                                   │    
      │ [16] <1,5,RECOVER-UPDATE-ACK>│                                   │    
      │ ─────────────────────────────>                                   │    
      │                              │                                   │    
      │   [17] <1,6,RECOVER-SUCESS>  │                                   │    
      │ <─────────────────────────────                                   │    
      │                              │                                   │    
      │                   [18]: <1,7,init-validateNext>                  │    
      │ ─────────────────────────────────────────────────────────────────>    
     ┌──┐                           ┌──┐                             ┌───────┐
     │G1│                           │G2│                             │Log API│
     └──┘                           └──┘                             └───────┘


## 7. Security Considerations

We assume a trusted, secure communication channel between gateways (i.e., messages cannot be spoofed and/or altered by an adversary) using TLS 1.3 or higher. Clients support “acceptable” credential schemes such as OAuth2.0.

The present protocol is crash fault-tolerant, meaning that it handles gateways that crash for several reasons (e.g., power outage). The present protocol does not support Byzantine faults, where gateways can behave arbitrarily (including being malicious). This implies that both gateways are considered trusted. We assume logs are not tampered with or lost.

Log entries need integrity, availability, and confidentiality guarantees, as they are an attractive point of attack [BVC19]. Every log entry contains a hash of its payload for guaranteeing integrity.  If extra guarantees are needed (e.g., non-repudiation),  a log entry might be signed by its creator. Availability is guaranteed by the usage of the log storage API that connects a gateway to a dependable storage (local, external, or DLT-based). Each underlying storage provides different guarantees. Access control can be enforced via the access control profile that each log can have associated with, i.e., the profile can be resolved, indicating who can access the log entry in which condition. Access control profiles can be implemented with access control lists for simple authorization. The authentication of the entities accessing the logs is done at the Log Storage API level (e.g., username+password authentication in local storage vs. blockchain-based access control in a DLT).

For extra guarantees, the nodes running the log storage API (or the gateway nodes themselves) can be protected by hardening technologies such as Intel SGX [CD16].


References

[Arch] https://datatracker.ietf.org/doc/draft-hardjono-blockchain-interop-arch/

[ODAP] https://datatracker.ietf.org/doc/draft-hargreaves-odap/

[BHG87] Bernstein, Philip A.; Hadzilacos, Vassos; Goodman, Nathan (1987). “Concurrency Control and Recovery in Database Systems,” Chapter 7. Addison Wesley Publishing Company.

[AD76] Alsberg, P. A. and Day,  J. D. (1976). “A principle for resilient sharing of distributed resources. In Proc. of the 2nd Int. Conf. on Software Engineering, pages 627-644.

[BVC19] Belchior, R., Vasconcelos, A., & Correia, M. (2020). Towards Secure, Decentralized, and Automatic Audits with Blockchain. European Conference on Information Systems.

[CD16] Costan, V., & Devadas, S. (2016). Intel SGX Explained. IACR Cryptol. ePrint Arch., 2016(86), 1-118.

[TLS] Rescorla, E. (2018). “The Transport Layer Security (TLS) Protocol Version 1.3”, RFC 8446.

[OIDC] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, "OpenID Connect Core 1.0", November 2014, <http://openid.net/specs/openid-connect-core-1_0.html>.

[HERMES] Belchior, R., Vasconcelos, A., Correia, M., Hardjono, T. (2021). TechRxiv 14120291
